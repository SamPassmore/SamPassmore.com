---
title: Ancestral state reconstruction with INLA
author: R package build
date: '2023-02-10'
slug: []
categories: []
tags: []
Description: ''
Tags: []
Categories: []
DisableComments: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, fig.align = 'center') 
set.seed(123)
```


A common task in phylogenetics is ancestral state reconstruction. There are a number of tools to do this inside and outside R. Some noteable R examples are: using [ape](http://ape-package.ird.fr/) (which I will use for comparison today), and [phytools](http://www.phytools.org/Rbook/), which are both frequentist implementations. Bayesian implementations are available using [BayesTraits](http://www.evolution.reading.ac.uk/BayesTraitsV4.0.0/BayesTraitsV4.0.0.html). This post shows how to implement a Bayesian ancestral state reconstruction approach using the R modelling package INLA. As with my previous INLA post, the process is a result of discussions with [Russell Dinnage](https://twitter.com/ecologician), and any mistakes are surely introduced by me. 

For comparison, I first simulate an ancestral state using ape:

```{r}
library(ape)

# Simulate a tree for n taxa. 
n = 100 
sim.tree = rcoal(n = n)

# Simulate a continuous trait along that tree, where the ancestral state is 5. 
y = rTraitCont(phy = sim.tree, root.value = 5)

# Calculate the ancestral state
anc = ace(y, sim.tree)
cat("The ancestral state is estimated to be:", round(anc$ace[1], 2), "\n",
    "With a 95% CI of:", round(anc$CI95[1,], 3))

```

The default ancestral state model is Brownian motion, and it does a pretty good job at estimating our known ancestral state of 5. This coding proceedure is pretty simple, and to code the same results in INLA is quite complicated, so you may ask why we need something more complicated, which I will discuss at the end. 

Next, we code the same model up in INLA. First is a small amount of data wrangling:

```{r}
library(INLA)
library(stringr)

# INLA requires the data as a dataframe. 
model_df = data.frame(label = names(y), y = y)

```

As discussed in my previous post, INLA requires a precision matrix. In this instance, I use `nodes = "ALL"` rather than `nodes = "TIPS"`. This means we include the relationships between all taxa and all nodes. We will use this information in reconstruction. 

```{r}
# INLA also requires the relationships between data to be 
# precision matrix
prec_mat = MCMCglmm::inverseA(sim.tree,
                   nodes = "ALL",
                   scale = FALSE)$Ainv
```

Next, we are going to include rows in our dataframe to represent the nodes. This will result in a dataframe that contains all our known data (the states of the taxa), and unknown data (the states of the internal nodes). The unknown data will be respresented with NA values. This next block also matches the rows of the dataframe to the rows of the precision matrix. 

```{r}
# add in node data
node_idx = str_detect(rownames(prec_mat), "Node")
node_df = data.frame(label = rownames(prec_mat)[node_idx], 
                     y = NA)

model_df = rbind(model_df, node_df)

model_df$phylo_id = match(model_df$label, rownames(prec_mat))
```

Now it is time to put it all together to calculate the ancestral states. To learn more about the construction of INLA models see my earlier post, or go to the INLA webpage. A difference in this model is `control.predictor=list(compute=TRUE)`. This tells the model to predict the values which are missing in the response, which are the internal nodes.  

```{r}
fit = inla(y ~ f(phylo_id,
                 model = "generic0",
                 Cmatrix = prec_mat), 
           data = model_df, 
           control.predictor=list(compute = TRUE),
           control.compute=list(config = TRUE)
           )


cat("The ancestral state is estimated to be:", round(fit$summary.fitted.values[101,1], 2), "\n",
    "With a 95% CI of:", unlist(round(fit$summary.fitted.values[101,c(3,5)], 3)))

```

Recall that the `ape::ace` function estimated the mean to be 4.98 (95% CI: 4.77 - 5). Both approaches are slightly underestimating the ancestral state (5), but INLA is providing a narrower confidence interval. Being a Bayesian approach, we can also plot a posterior distribution of the results:

```{r}
post = INLA::inla.posterior.sample(1000, fit)
anc.post = lapply(post, function(p) p$latent[101]) %>% 
  unlist()

plot(density(anc.post), main = "Posterior distribution of Ancestral State estimates",
     xlab = "Ancestral state Estimate", col = "blue")
abline(v = unlist(fit$summary.fitted.values[101,1]), lty = "dashed", col = "blue")
abline(v = unlist(fit$summary.fitted.values[101,c(3,5)]), lty = "dashed", col = "blue")
abline(v = anc$ace[1], lty = "dashed", col = "red")
abline(v = anc$CI95[1,], lty = "dashed", col = "red")
```

